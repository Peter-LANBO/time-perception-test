<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>サークルテスト（最終版）</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: "Hiragino Kaku Gothic Pro", sans-serif;
      background: #f0f0f0;
    }
    .container {
      width: 95%;
      max-width: 1200px;
      margin: 20px auto;
      background: #fff;
      padding: 30px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    h2 {
      margin-top: 0;
      color: #2c3e50;
    }
    .btn {
      display: inline-block;
      padding: 10px 25px;
      margin: 10px 5px;
      border: none;
      background: #3498db;
      color: #fff;
      cursor: pointer;
      border-radius: 5px;
      font-size: 15px;
      transition: background 0.3s;
    }
    .btn:hover {
      background: #2980b9;
    }
    .canvas-box {
      border: 1px solid #ddd;
      margin: 15px 0;
      position: relative;
      background: #fff;
    }
    .step {
      display: none;
    }
    .step.active {
      display: block;
    }
    canvas {
      background: #fff;
      cursor: crosshair;
    }
    .note {
      background: #f8f9fa;
      padding: 15px;
      margin: 15px 0;
      border-left: 4px solid #3498db;
      border-radius: 4px;
    }
    .control-panel {
      margin: 25px 0;
      display: flex;
      gap: 15px;
      align-items: center;
    }
    select, button {
      padding: 9px 18px;
      border: 1px solid #3498db;
      border-radius: 5px;
      background: #3498db;
      color: white;
      cursor: pointer;
      font-size: 15px;
    }
    .a4-sheet {
      display: flex;
      gap: 30px;
      margin-top: 25px;
    }
    .instruction-panel {
      flex: 1;
      min-width: 300px;
      padding-right: 30px;
    }
    .draw-container {
      width: 800px;
      height: 800px;
      border: 2px solid #2c3e50;
      position: relative;
      background: #fff;
    }
    #circleCanvas {
      width: 100%;
      height: 100%;
    }
    .counter {
      color: #7f8c8d;
      font-size: 14px;
    }
    .fullscreen-prompt {
      text-align: center;
      padding: 50px;
    }
    /* 自定义模态窗口样式 */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal-content {
      background: #fff;
      padding: 20px 30px;
      border-radius: 8px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .modal-content p {
      margin-bottom: 20px;
      font-size: 16px;
      color: #2c3e50;
    }
  </style>
</head>
<body>
<div class="container">

  <!-- Step 0: フルスクリーン説明 -->
  <div id="step0" class="step active">
    <div class="fullscreen-prompt">
      <h2>実験説明</h2>
      <p>この実験は正確な計測が必要なため、フルスクリーンモードで実施してください</p>
      <button class="btn" onclick="enterFullscreen()">フルスクリーンで開始</button>
    </div>
  </div>

  <!-- Step 1: 1回目キャリブレーション -->
  <div id="step1" class="step">
    <div class="note">
      <label>
        <input type="checkbox" id="rulerCheck" required>
        物理定規を準備しました（キャリブレーション用）
      </label>
    </div>
    <h2>【ステップ1】2cmキャリブレーション（1回目）</h2>
    <p>定規を画面に当て、下のキャンバスに<mark>2cmの直線</mark>を描いてください</p>
    <div class="canvas-box">
      <canvas id="calibCanvas1" width="800" height="500"></canvas>
    </div>
    <button class="btn" id="clearCalib1">リセット</button>
    <button class="btn" id="confirmCalib1">確定</button>
  </div>

  <!-- Step 2: 2回目キャリブレーション -->
  <div id="step2" class="step">
    <h2>【ステップ2】2cmキャリブレーション（2回目）</h2>
    <p class="note">2回の計測値の一致度が95%以上必要です</p>
    <div class="canvas-box">
      <canvas id="calibCanvas2" width="800" height="500"></canvas>
    </div>
    <button class="btn" id="clearCalib2">リセット</button>
    <button class="btn" id="confirmCalib2">確定</button>
  </div>

  <!-- Step 3: サークルテスト -->
  <div id="step3" class="step">
    <h2>【ステップ3】サークルテスト</h2>
    
    <div class="a4-sheet">
      <div class="instruction-panel">
        <p>以下の指示を詳しく読んで、回答してください：<br>
        過去、現在、未来が円で表されると考えて、あなた自身の過去、現在、未来の関係について、あなたの見方を最もあらわすように、枠の中で自由に3つの円を書いてください、描き方は自由です。円のサイズと位置を変えてもかまいません。描き終わったら、どの円が過去、現在、未来か分かるように書き入れてください。</p>
        
        <div class="note">
          <strong>操作ガイド</strong>
          <ul>
            <li>ラベル選択後、キャンバスをドラッグで円作成（最大3つ）</li>
            <li>円を<strong>単クリック</strong>：ラベルの表示／非表示切替</li>
            <li>円周をドラッグ：サイズ変更</li>
            <li>円内部を1.5秒長押し後ドラッグ：移動</li>
          </ul>
        </div>
        
        <!-- 将“ラベル選択”、“結果出力”、“リセット”的控制面板移至说明文字之上 -->
        <div class="control-panel">
          <select id="labelSelector">
            <option value="">ラベルを選択</option>
            <option value="過去">過去</option>
            <option value="現在">現在</option>
            <option value="未来">未来</option>
          </select>
          <span class="counter" id="circleCounter">作成済み：0/3</span>
        </div>
        <div class="control-panel">
          <button class="btn" onclick="handleExport()">結果出力</button>
          <button class="btn" onclick="resetCircleCanvas()">リセット</button>
        </div>
        
        <p style="font-size: 15px; color: #2c3e50; margin-top: 15px;">
          ※ 結果出力について：図の作成が完了したら、左下の【結果出力】ボタンをクリックしてください。<br>
          すると、<strong>CSVファイルとJPG画像の2つのファイルがダウンロード</strong>されます。<br>
          ダウンロードされたファイルは、必ず<strong>メール本文に学生番号の後8桁</strong>を記入の上、<br>
          指定のメールアドレス <strong>wohanhailong1993@outlook.com へ送信</strong>してください。
        </p>
      </div>

      <div class="draw-container">
        <canvas id="circleCanvas"></canvas>
      </div>
    </div>
  </div>

</div>

<!-- 自定义模态窗口，用于替代 alert/confirm -->
<div id="modalOverlay" class="modal-overlay">
  <div class="modal-content">
    <p id="modalMessage"></p>
    <button id="modalOk" class="btn">OK</button>
    <button id="modalCancel" class="btn" style="display: none;">キャンセル</button>
  </div>
</div>

<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
<script>
  // 全局变量
  let currentStep = 0;
  let calibResults = [null, null];
  let pxToMm = 0;
  let circles = [];
  let currentLabel = '';
  let selectedCircle = null;
  const CANVAS_SIZE = 800;
  // 为方便导出时调用更新函数，将圆画布的更新函数设为全局变量（后续在 initCircleCanvas 中赋值）
  let updateCircleDisplay = null;

  // 自定义模态窗口实现：customAlert 和 customConfirm
  function showModal(message, options = {confirmOnly: true}) {
    return new Promise(resolve => {
      const modalOverlay = document.getElementById('modalOverlay');
      const modalMessage = document.getElementById('modalMessage');
      const modalOk = document.getElementById('modalOk');
      const modalCancel = document.getElementById('modalCancel');
      
      modalMessage.textContent = message;
      modalOverlay.style.display = 'flex';
      
      if(options.confirmOnly) {
        modalCancel.style.display = 'none';
      } else {
        modalCancel.style.display = 'inline-block';
      }
      
      // 清除之前的事件监听
      modalOk.onclick = () => {
        modalOverlay.style.display = 'none';
        resolve(true);
      };
      modalCancel.onclick = () => {
        modalOverlay.style.display = 'none';
        resolve(false);
      };
    });
  }

  async function customAlert(message) {
    await showModal(message, {confirmOnly: true});
  }
  
  async function customConfirm(message) {
    return await showModal(message, {confirmOnly: false});
  }

  // 全屏模式
  function enterFullscreen() {
    document.documentElement.requestFullscreen().then(() => {
      navigateTo(1);
    });
  }

  // 步骤切换函数
  function navigateTo(step) {
    document.querySelectorAll('.step').forEach(el => el.style.display = 'none');
    document.getElementById(`step${step}`).style.display = 'block';
    currentStep = step;
  }

  // キャリブレーション管理クラス
  class CalibrationCanvas {
    constructor(id) {
      this.canvas = document.getElementById(id);
      this.ctx = this.canvas.getContext('2d');
      this.lines = [];
      this.isDrawing = false;
      this.initEvents();
    }

    initEvents() {
      // 将 mousedown 处理函数声明为 async，以便使用 await customAlert
      this.canvas.addEventListener('mousedown', async e => await this.startDrawing(e));
      this.canvas.addEventListener('mousemove', e => this.draw(e));
      this.canvas.addEventListener('mouseup', () => this.stopDrawing());
    }

    async startDrawing(e) {
      if (currentStep === 1 && !document.getElementById('rulerCheck').checked) {
        await customAlert('定規の準備を確認してください');
        return;
      }
      const pos = this.getPosition(e);
      this.isDrawing = true;
      this.lines = [{x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y}];
    }

    draw(e) {
      if (!this.isDrawing) return;
      const pos = this.getPosition(e);
      this.lines[0].x2 = pos.x;
      this.lines[0].y2 = pos.y;
      this.render();
    }

    stopDrawing() {
      this.isDrawing = false;
      this.render();
    }

    getPosition(e) {
      const rect = this.canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }

    render() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.lines.forEach(line => {
        this.ctx.beginPath();
        this.ctx.moveTo(line.x1, line.y1);
        this.ctx.lineTo(line.x2, line.y2);
        this.ctx.strokeStyle = '#2c3e50';
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
      });
    }

    getLineLength() {
      return this.lines.length ? 
        Math.hypot(
          this.lines[0].x2 - this.lines[0].x1,
          this.lines[0].y2 - this.lines[0].y1
        ) : 0;
    }

    clear() {
      this.lines = [];
      this.render();
    }
  }

  // キャリブレーション处理
  const calib1 = new CalibrationCanvas('calibCanvas1');
  const calib2 = new CalibrationCanvas('calibCanvas2');

  document.getElementById('confirmCalib1').addEventListener('click', async () => {
    if (calib1.getLineLength() < 10) {
      await customAlert('キャリブレーション線を描いてください');
      return;
    }
    calibResults[0] = calib1.getLineLength();
    navigateTo(2);
  });

  document.getElementById('confirmCalib2').addEventListener('click', async () => {
    const len = calib2.getLineLength();
    if (len < 10) {
      await customAlert('キャリブレーション線を描いてください');
      return;
    }
    calibResults[1] = len;

    const min = Math.min(...calibResults);
    const max = Math.max(...calibResults);
    if ((min / max) < 0.95) {
      await customAlert('2回の計測値の一致度が95%未満です。再描画してください');
      calib2.clear();
      return;
    }

    pxToMm = 20 / ((calibResults[0] + calibResults[1]) / 2);
    navigateTo(3);
    initCircleCanvas();
  });

  // サークルテスト功能
  function initCircleCanvas() {
    const canvas = document.getElementById('circleCanvas');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    
    canvas.width = CANVAS_SIZE * dpr;
    canvas.height = CANVAS_SIZE * dpr;
    ctx.scale(dpr, dpr);

    let currentCircle = null;
    let isDrawing = false;
    let actionType = null;
    let pressTimer = null;

    function getPosition(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) * (CANVAS_SIZE / rect.width),
        y: (e.clientY - rect.top) * (CANVAS_SIZE / rect.height)
      };
    }

    function enforceBoundary(circle) {
      const maxRadius = Math.min(
        circle.x - 5,
        CANVAS_SIZE - circle.x - 5,
        circle.y - 5,
        CANVAS_SIZE - circle.y - 5
      );
      circle.radius = Math.min(circle.radius, maxRadius);
      return circle;
    }

    // 将 updateDisplay 函数设为全局变量，便于导出时调用
    updateCircleDisplay = function updateDisplay() {
      ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
      drawGrid();
      
      // 绘制预览（如果正在绘制新圆）
      if (isDrawing && currentCircle) {
        ctx.beginPath();
        ctx.arc(currentCircle.x, currentCircle.y, currentCircle.radius, 0, Math.PI * 2);
        ctx.strokeStyle = '#3498db';
        ctx.setLineDash([5, 3]);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      circles.forEach(c => {
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // 如果当前设置为显示标签，则绘制标签
        if (c.showLabel) {
          ctx.fillStyle = '#2c3e50';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(c.label, c.x, c.y);
        }
      });
      
      document.getElementById('circleCounter').textContent = `作成済み：${circles.length}/3`;
    };

    function drawGrid() {
      ctx.strokeStyle = '#ecf0f1';
      ctx.lineWidth = 1;
      for (let i = 0; i <= CANVAS_SIZE; i += 40) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, CANVAS_SIZE);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(CANVAS_SIZE, i);
        ctx.stroke();
      }
    }

    // 监听鼠标按下事件（用于新建圆或启动现有圆的拖动／尺寸调整）
    canvas.addEventListener('mousedown', e => {
      const pos = getPosition(e);
      
      // 新建圆：只有在选择了标签且当前创建的圆数量不足3时生效
      if (currentLabel && circles.length < 3) {
        isDrawing = true;
        currentCircle = enforceBoundary({
          x: pos.x,
          y: pos.y,
          radius: 0,
          label: currentLabel,
          showLabel: true
        });
        return;
      }

      // 查找点击的已有圆（用于拖动或尺寸调整）
      selectedCircle = circles.find(c => {
        const dist = Math.hypot(pos.x - c.x, pos.y - c.y);
        return dist < c.radius + 5;
      });

      if (selectedCircle) {
        const edgeDist = Math.abs(
          Math.hypot(pos.x - selectedCircle.x, pos.y - selectedCircle.y) - selectedCircle.radius
        );
        
        if (edgeDist < 10) {
          actionType = 'resize';
        } else {
          pressTimer = setTimeout(() => {
            actionType = 'move';
            canvas.style.cursor = 'move';
          }, 1500);
        }
      }
    });

    // 鼠标移动事件
    canvas.addEventListener('mousemove', e => {
      const pos = getPosition(e);
      
      if (isDrawing) {
        currentCircle.radius = Math.hypot(pos.x - currentCircle.x, pos.y - currentCircle.y);
        enforceBoundary(currentCircle);
        updateCircleDisplay();
        return;
      }

      if (actionType === 'resize' && selectedCircle) {
        selectedCircle.radius = Math.hypot(pos.x - selectedCircle.x, pos.y - selectedCircle.y);
        enforceBoundary(selectedCircle);
        updateCircleDisplay();
      }

      if (actionType === 'move' && selectedCircle) {
        selectedCircle.x = Math.max(selectedCircle.radius + 5, 
          Math.min(pos.x, CANVAS_SIZE - selectedCircle.radius - 5));
        selectedCircle.y = Math.max(selectedCircle.radius + 5, 
          Math.min(pos.y, CANVAS_SIZE - selectedCircle.radius - 5));
        updateCircleDisplay();
      }
    });

    canvas.addEventListener('mouseup', () => {
      clearTimeout(pressTimer);
      
      if (isDrawing) {
        if (currentCircle.radius > 10) {
          circles.push(currentCircle);
          document.getElementById('labelSelector').value = '';
          currentLabel = '';
        }
        isDrawing = false;
        currentCircle = null;
      }
      
      actionType = null;
      selectedCircle = null;
      canvas.style.cursor = 'default';
      updateCircleDisplay();
    });

    // 新增“点击”事件，实现单击圆切换标签显示/隐藏
    canvas.addEventListener('click', e => {
      // 如果正在绘制或处于拖动状态，则不响应点击事件
      if (isDrawing || actionType) return;
      const pos = getPosition(e);
      const clickedCircle = circles.find(c => Math.hypot(pos.x - c.x, pos.y - c.y) <= c.radius);
      if (clickedCircle) {
        clickedCircle.showLabel = !clickedCircle.showLabel;
        updateCircleDisplay();
      }
    });

    // 监听标签选择框变化
    document.getElementById('labelSelector').addEventListener('change', async e => {
      currentLabel = e.target.value;
      if (circles.some(c => c.label === currentLabel)) {
        await customAlert('このラベルは既に使用されています');
        e.target.value = '';
        currentLabel = '';
      }
    });

    // 初次绘制
    updateCircleDisplay();
  }

  // 数据输出功能
  async function handleExport() {
    if (circles.length !== 3) {
      await customAlert('3つの円を作成してください');
      return;
    }

    const confirmResult = await customConfirm('この結果を出力しますか？');
    if (!confirmResult) return;
    
    // 退出全屏模式（确保输出前退出全屏）
    if (document.fullscreenElement) {
      await document.exitFullscreen();
    }

    // 为确保导出的图片中显示标签，无论当前状态如何，
    // 暂时保存各圆的原始 showLabel 状态，并全部设为 true
    const originalShowLabel = circles.map(c => c.showLabel);
    circles.forEach(c => c.showLabel = true);
    if (updateCircleDisplay) updateCircleDisplay();

    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
    
    // CSV 文件输出
    const distances = [
      calcDistance(circles[0], circles[1]),
      calcDistance(circles[1], circles[2]),
      calcDistance(circles[0], circles[2])
    ].map(d => (d * pxToMm).toFixed(2));

    const csvData = circles.map((c, i) => ({
      ラベル: c.label,
      半径mm: (c.radius * pxToMm).toFixed(2),
      面積mm2: (Math.PI * Math.pow(c.radius * pxToMm, 2)).toFixed(2),
      過去現在距離: i === 0 ? distances[0] : '',
      現在未来距離: i === 1 ? distances[1] : '',
      過去未来距離: i === 2 ? distances[2] : ''
    }));

    const csvContent = [
      'ラベル,半径(mm),面積(mm²),過去-現在距離(mm),現在-未来距離(mm),過去-未来距離(mm)',
      ...csvData.map(d => `${d.ラベル},${d.半径mm},${d.面積mm2},${d.過去現在距離},${d.現在未来距離},${d.過去未来距離}`)
    ].join('\n');

    const csvLink = document.createElement('a');
    csvLink.href = URL.createObjectURL(new Blob([csvContent], {type: 'text/csv;charset=utf-8;'}));
    csvLink.download = `サークルテスト_${timestamp}.csv`;
    csvLink.click();

    // 图片（JPG）输出：使用 html2canvas 导出绘图区域（包含标签）
    const canvasElem = await html2canvas(document.querySelector('.draw-container'), {
      scale: 2,
      useCORS: true
    });
    
    const imgLink = document.createElement('a');
    imgLink.href = canvasElem.toDataURL('image/jpeg', 0.9);
    imgLink.download = `サークルテスト_${timestamp}.jpg`;
    imgLink.click();

    // 恢复各圆原始的标签显示状态，并重绘
    circles.forEach((c, i) => c.showLabel = originalShowLabel[i]);
    if (updateCircleDisplay) updateCircleDisplay();
  }

  // 工具函数
  function calcDistance(c1, c2) {
    return Math.hypot(c1.x - c2.x, c1.y - c2.y);
  }

  function resetCircleCanvas() {
    circles = [];
    document.getElementById('labelSelector').value = '';
    currentLabel = '';
    initCircleCanvas();
  }

  // 初始化：清空按钮绑定
  document.getElementById('clearCalib1').addEventListener('click', () => calib1.clear());
  document.getElementById('clearCalib2').addEventListener('click', () => calib2.clear());
</script>
</body>
</html>
