<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Calibration + Circle Test Demo (Modified)</title>
  <style>
    body {
      margin: 0; 
      padding: 0;
      font-family: "Hiragino Kaku Gothic Pro", sans-serif;
      background: #f0f0f0;
    }
    .container {
      width: 90%;
      max-width: 1200px;
      margin: 30px auto;
      background: #fff;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    h2 {
      margin-top: 0;
    }
    .btn {
      display: inline-block;
      padding: 10px 20px;
      margin: 10px 0;
      border: none;
      background: #3498db;
      color: #fff;
      cursor: pointer;
      border-radius: 5px;
      font-size: 14px;
    }
    .btn:hover {
      background: #2980b9;
    }
    /* キャンバスを包むコンテナ */
    .canvas-box {
      display: inline-block; /* canvas に合わせてサイズが自動調整される */
      border: 1px solid #ccc;
      margin: 10px 0;
      position: relative;
    }
    /* 各ステップの表示制御 */
    .step {
      display: none;
    }
    .step.active {
      display: block;
    }
    /* キャリブレーションやCircle用キャンバス共通のスタイル */
    canvas {
      background: #fff;
      cursor: crosshair;
      display: block; /* ブロック要素にし、余白をなくす */
    }
    .note {
      background: #f8f9fa;
      padding: 10px;
      margin: 10px 0;
      border-left: 3px solid #3498db;
    }
    .control-panel {
      margin: 20px 0;
    }
    select, button {
      padding: 8px 16px;
      margin-right: 10px;
      border: 1px solid #3498db;
      border-radius: 4px;
      background: #3498db;
      color: white;
      cursor: pointer;
      transition: 0.3s;
      font-size: 14px;
    }
    select:hover, button:hover {
      background: #2980b9;
    }
    /* Circle Test用 */
    .a4-sheet {
      display: flex;
      gap: 20px;
      margin-top: 20px;
    }
    .instruction-panel {
      flex: 1;
      border-right: 2px solid #ecf0f1;
      padding-right: 20px;
      min-width: 250px;
    }
    .draw-container {
      width: 567px;
      height: 567px;
      border: 2px solid #2c3e50;
      position: relative;
    }
    #circleCanvas {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
  </style>
</head>
<body>
<div class="container">

  <!-- ================= STEP 1: Calibration 1 ================= -->
  <div id="step1" class="step active">
    <h2>【Step1】2cmキャリブレーション（1回目）</h2>
    <p>お手元の定規を画面に当て、下のキャンバス上に<mark>2cmの直線</mark>を描いてください。</p>
    <p class="note">
      - クリック＆ドラッグで線を1本描画してください。<br>
      - 調整が終わったら「確定」ボタンを押してください。<br>
      - 後で2回目のキャリブレーション（Step2）でもう一度同じ操作を行います。
    </p>
    <div class="canvas-box">
      <!-- 幅600, 高さ400をHTML属性で指定し、CSSでは固定しない -->
      <canvas id="calibCanvas1" width="600" height="400"></canvas>
    </div>
    <button class="btn" id="clearCalib1">やり直し（リセット）</button>
    <button class="btn" id="confirmCalib1">確定</button>
  </div>

  <!-- ================= STEP 2: Calibration 2 ================= -->
  <div id="step2" class="step">
    <h2>【Step2】2cmキャリブレーション（2回目）</h2>
    <p>もう一度、同じ要領で<mark>2cmの直線</mark>を描いてください。</p>
    <p class="note">
      - 前回と同じ操作です。<br>
      - 2回の計測結果が95%（±5%）以上一致しないと次に進めません。
    </p>
    <div class="canvas-box">
      <canvas id="calibCanvas2" width="600" height="400"></canvas>
    </div>
    <button class="btn" id="clearCalib2">やり直し（リセット）</button>
    <button class="btn" id="confirmCalib2">確定</button>
  </div>

  <!-- ================= STEP 3: Circle Test ================= -->
  <div id="step3" class="step">
    <h2>【Step3】Circle Test</h2>

    <div class="a4-sheet">
      <!-- 左側パネル（操作ガイド＆指示文＆操作区） -->
      <div class="instruction-panel">
        <!-- 指示文を追加 -->
        <p>
          以下の指示を詳しく読んで、回答してください：<br><br>
          過去、現在、未来が円で表されると考えて、あなた自身の過去、現在、未来の関係について、あなたの見方を最もあらわすように、枠の中で自由に3つの円を書いてください、描き方は自由です。円のサイズと位置を変えてもかまいません。描き終わったら、どの円が過去、現在、未来か分かるように書き入れてください。
        </p>

        <!-- 操作ガイド -->
        <div class="note">
          <strong>操作ガイド</strong><br>
          ・「ラベルを選択」してからキャンバスをドラッグ → 円を作成（最大3つ）<br>
          ・ 既存の円の操作：<br>
          &emsp;- 短押しクリック：ラベルの表示/非表示切り替え<br>
          &emsp;- 円周付近をクリック→すぐドラッグ：リサイズ<br>
          &emsp;- 円の内部を1.5秒以上押し続ける→ドラッグ：円の移動
        </div>

        <!-- 操作区 -->
        <div class="control-panel">
          <select id="labelSelector">
            <option value="">ラベルを選択</option>
            <option value="過去">過去</option>
            <option value="現在">現在</option>
            <option value="未来">未来</option>
          </select>
          <button onclick="exportCircleData()">CSV出力</button>
          <button onclick="saveCircleImage()">画像保存</button>
          <button onclick="resetCircleCanvas()">リセット</button>
        </div>
      </div>

      <!-- 右側パネル（描画エリア） -->
      <div class="draw-container">
        <canvas id="circleCanvas"></canvas>
      </div>
    </div>
  </div>

</div>

<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
<script>
// ========================================================
//  グローバル変数・状態管理
// ========================================================
let step = 1;                    // 現在のステップ(1→2→3)
let calibLengths = [null, null]; // キャリブレーション結果(px)
let mmPerPx = 0;                 // px→mm換算係数 (2cm=20mmが何pxに相当するか)

// --------------------------------------------------------
//  STEP切り替え
// --------------------------------------------------------
function showStep(nextStep) {
  const steps = [1,2,3];
  steps.forEach(s => {
    document.getElementById(`step${s}`).style.display = (s === nextStep) ? 'block' : 'none';
  });
  step = nextStep;
}

// ========================================================
//  STEP1 & STEP2: キャリブレーションCanvas
// ========================================================
class CalibCanvasManager {
  constructor(canvasId) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.width = this.canvas.width;
    this.height = this.canvas.height;
    this.lines = [];      // 引いた線（1本前提）
    this.isDrawing = false;
    this.currentLine = null;

    this.canvas.addEventListener('mousedown', (e)=>this.onMouseDown(e));
    this.canvas.addEventListener('mousemove', (e)=>this.onMouseMove(e));
    this.canvas.addEventListener('mouseup',   (e)=>this.onMouseUp(e));
  }

  onMouseDown(e) {
    this.isDrawing = true;
    const pos = this.getPos(e);
    this.currentLine = { x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y };
  }

  onMouseMove(e) {
    if(!this.isDrawing || !this.currentLine) return;
    const pos = this.getPos(e);
    this.currentLine.x2 = pos.x;
    this.currentLine.y2 = pos.y;
    this.redraw();
  }

  onMouseUp(e) {
    if(!this.isDrawing) return;
    this.isDrawing = false;
    if(this.currentLine) {
      // 最新の線1本だけ保持
      this.lines = [ this.currentLine ];
      this.currentLine = null;
    }
    this.redraw();
  }

  getPos(e) {
    const rect = this.canvas.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }

  redraw() {
    this.ctx.clearRect(0, 0, this.width, this.height);
    // すでに描かれた線
    this.lines.forEach(line => {
      this.ctx.beginPath();
      this.ctx.moveTo(line.x1, line.y1);
      this.ctx.lineTo(line.x2, line.y2);
      this.ctx.strokeStyle = '#2c3e50';
      this.ctx.lineWidth = 2;
      this.ctx.stroke();
    });
    // 現在ドラッグ中のライン
    if(this.currentLine) {
      this.ctx.beginPath();
      this.ctx.moveTo(this.currentLine.x1, this.currentLine.y1);
      this.ctx.lineTo(this.currentLine.x2, this.currentLine.y2);
      this.ctx.strokeStyle = '#7f8c8d';
      this.ctx.setLineDash([5,5]);
      this.ctx.stroke();
      this.ctx.setLineDash([]);
    }
  }

  getLineLengthPx() {
    if(this.lines.length === 0) return 0;
    const ln = this.lines[0];
    const dx = ln.x2 - ln.x1;
    const dy = ln.y2 - ln.y1;
    return Math.sqrt(dx*dx + dy*dy);
  }

  clearAll() {
    this.lines = [];
    this.currentLine = null;
    this.ctx.clearRect(0,0,this.width,this.height);
  }
}

// キャリブ用Canvas
const calib1 = new CalibCanvasManager("calibCanvas1");
const calib2 = new CalibCanvasManager("calibCanvas2");

// リセットボタン
document.getElementById('clearCalib1').addEventListener('click', ()=> calib1.clearAll());
document.getElementById('clearCalib2').addEventListener('click', ()=> calib2.clearAll());

// 確定ボタン1
document.getElementById('confirmCalib1').addEventListener('click', ()=>{
  const lenPx = calib1.getLineLengthPx();
  if(lenPx <= 0) {
    alert("線が描かれていません。描いてから確定してください。");
    return;
  }
  calibLengths[0] = lenPx;
  // 次のSTEPへ
  showStep(2);
});

// 確定ボタン2
document.getElementById('confirmCalib2').addEventListener('click', ()=>{
  const lenPx = calib2.getLineLengthPx();
  if(lenPx <= 0) {
    alert("線が描かれていません。描いてから確定してください。");
    return;
  }
  calibLengths[1] = lenPx;

  // 一致度チェック
  const smaller = Math.min(calibLengths[0], calibLengths[1]);
  const larger  = Math.max(calibLengths[0], calibLengths[1]);
  const percentage = (smaller / larger) * 100;

  if(percentage < 95) {
    alert("2回の計測値が95%未満です。もう一度描き直してください。");
    // リセット
    calib2.clearAll();
    calibLengths[1] = null;
    return;
  }

  // 合格 → 平均値を使う
  const avgPx = (calibLengths[0] + calibLengths[1]) / 2;
  mmPerPx = 20.0 / avgPx; // 2cm=20mm

  alert(`キャリブレーション完了！ 1pxあたり約${mmPerPx.toFixed(4)}mm です。`);
  showStep(3);
});


// ========================================================
//   STEP3: Circle Test
// ========================================================
const circleCanvas = document.getElementById("circleCanvas");
const circleCtx = circleCanvas.getContext("2d");
const circleSize = 567; // 描画領域

// 高解像度対応
let dpr = window.devicePixelRatio || 1;
circleCanvas.width = circleSize * dpr;
circleCanvas.height = circleSize * dpr;
circleCtx.scale(dpr, dpr);

let circles = [];
let currentLabel = '';
let isDrawingCircle = false;
let currentCircle = null;

let selectedCircle = null;
let operationMode = 'none';  // 'move' or 'resize'
let pressTimer = null;
let pressStartCircle = null;
let longPressThreshold = 1500; // 1.5秒

function getCirclePos(e) {
  const rect = circleCanvas.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left)*(circleSize/rect.width),
    y: (e.clientY - rect.top)*(circleSize/rect.height)
  };
}

function redrawCircleCanvas() {
  circleCtx.clearRect(0, 0, circleSize, circleSize);
  drawGrid();
  drawAllCircles();
  drawPreview();
}

function drawGrid() {
  circleCtx.strokeStyle = '#ecf0f1';
  circleCtx.lineWidth = 1;
  for(let i=0; i<=circleSize; i+=37.8) {
    circleCtx.beginPath();
    circleCtx.moveTo(i,0);
    circleCtx.lineTo(i,circleSize);
    circleCtx.stroke();
    circleCtx.beginPath();
    circleCtx.moveTo(0,i);
    circleCtx.lineTo(circleSize,i);
    circleCtx.stroke();
  }
}

function drawAllCircles() {
  circles.forEach(c => {
    circleCtx.beginPath();
    circleCtx.arc(c.x, c.y, c.radius, 0, 2*Math.PI);
    circleCtx.strokeStyle = '#2c3e50';
    circleCtx.lineWidth = 2;
    circleCtx.stroke();

    if(c.showText) {
      circleCtx.fillStyle = '#2c3e50';
      circleCtx.font = 'bold 14px sans-serif';
      circleCtx.textAlign = 'center';
      circleCtx.textBaseline = 'middle';
      circleCtx.fillText(c.label, c.x, c.y);
    }

    // 選択中を点線表示
    if(c === selectedCircle && (operationMode === 'move' || operationMode === 'resize')) {
      circleCtx.save();
      circleCtx.setLineDash([5,3]);
      circleCtx.strokeStyle = '#3498db';
      circleCtx.lineWidth = 2;
      circleCtx.beginPath();
      circleCtx.arc(c.x, c.y, c.radius, 0, 2*Math.PI);
      circleCtx.stroke();
      circleCtx.restore();
    }
  });
}

function drawPreview() {
  if(!currentCircle) return;
  circleCtx.save();
  circleCtx.setLineDash([5,5]);
  circleCtx.strokeStyle = '#7f8c8d';
  circleCtx.beginPath();
  circleCtx.arc(currentCircle.x, currentCircle.y, currentCircle.radius, 0, 2*Math.PI);
  circleCtx.stroke();
  circleCtx.restore();
}

function isInCircle(pos, circle) {
  return Math.hypot(pos.x - circle.x, pos.y - circle.y) < circle.radius;
}
function isNearEdge(pos, circle) {
  let dist = Math.hypot(pos.x - circle.x, pos.y - circle.y);
  return Math.abs(dist - circle.radius) < 10;
}

// 新規円作成 or 既存円操作
circleCanvas.addEventListener('mousedown', (e)=>{
  // 新規円？
  if(currentLabel && circles.length < 3) {
    isDrawingCircle = true;
    const pos = getCirclePos(e);
    currentCircle = { x: pos.x, y: pos.y, radius: 0, label: currentLabel, showText: false };
    return;
  }

  // リサイズ判定
  const pos = getCirclePos(e);
  let foundResize = false;
  circles.forEach(c => {
    if(isNearEdge(pos, c)) {
      selectedCircle = c;
      operationMode = 'resize';
      circleCanvas.style.cursor = 'nesw-resize';
      foundResize = true;
    }
  });
  if(foundResize) return;

  // 内部長押し → move
  let foundInside = null;
  circles.forEach(c => {
    if(isInCircle(pos,c)) {
      foundInside = c;
    }
  });
  if(foundInside) {
    pressStartCircle = foundInside;
    pressTimer = setTimeout(()=>{
      selectedCircle = pressStartCircle;
      operationMode = 'move';
      circleCanvas.style.cursor = 'move';
      redrawCircleCanvas();
    }, longPressThreshold);
  }
});

circleCanvas.addEventListener('mousemove', (e)=>{
  const pos = getCirclePos(e);

  // 新規円描画中
  if(isDrawingCircle && currentCircle) {
    const dx = pos.x - currentCircle.x;
    const dy = pos.y - currentCircle.y;
    currentCircle.radius = Math.sqrt(dx*dx + dy*dy);
    redrawCircleCanvas();
    return;
  }

  // リサイズ中
  if(selectedCircle && operationMode === 'resize') {
    const dx = pos.x - selectedCircle.x;
    const dy = pos.y - selectedCircle.y;
    selectedCircle.radius = Math.sqrt(dx*dx + dy*dy);
    redrawCircleCanvas();
    return;
  }

  // 移動中
  if(selectedCircle && operationMode === 'move') {
    selectedCircle.x = pos.x;
    selectedCircle.y = pos.y;
    redrawCircleCanvas();
    return;
  }

  // 通常時のカーソル
  let hoverCircle = circles.find(c => isNearEdge(pos,c));
  circleCanvas.style.cursor = hoverCircle ? 'nesw-resize' : 'crosshair';
});

circleCanvas.addEventListener('mouseup', (e)=>{
  // 新規円確定
  if(isDrawingCircle && currentCircle) {
    if(currentCircle.radius > 5) {
      circles.push(currentCircle);
      // ラベルを消費
      document.getElementById('labelSelector').value = '';
      currentLabel = '';
    }
    currentCircle = null;
    isDrawingCircle = false;
    redrawCircleCanvas();
    return;
  }

  // 長押しタイマーキャンセル
  if(pressTimer) {
    clearTimeout(pressTimer);
    pressTimer = null;
  }

  // リサイズ・移動終了
  if(operationMode === 'resize' || operationMode === 'move') {
    selectedCircle = null;
    operationMode = 'none';
    circleCanvas.style.cursor = 'crosshair';
    return;
  }

  // 短押し → ラベル表示切替
  const pos = getCirclePos(e);
  let clickedCircle = circles.find(c => isInCircle(pos,c));
  if(clickedCircle) {
    clickedCircle.showText = !clickedCircle.showText;
    redrawCircleCanvas();
  }
});

// リセット（円を全消去）
function resetCircleCanvas() {
  circles = [];
  currentLabel = '';
  document.getElementById('labelSelector').value = '';
  redrawCircleCanvas();
}

// ラベル選択
document.getElementById('labelSelector').addEventListener('change',(e)=>{
  currentLabel = e.target.value;
  if(currentLabel && circles.some(c=> c.label === currentLabel)) {
    alert('このラベルは既に使用されています');
    e.target.value = '';
    currentLabel = '';
  }
});

// CSV出力
function exportCircleData() {
  if(circles.length !== 3) {
    alert('円を3つ作成してからCSV出力してください。');
    return;
  }
  // px→mm換算
  // 半径(mm) = circle.radius * mmPerPx
  // 面積(mm²) = π * (radius(mm))^2
  // 距離(mm) = pxDistance * mmPerPx

  const dist = [
    calcDistance(circles[0], circles[1]),
    calcDistance(circles[1], circles[2]),
    calcDistance(circles[0], circles[2])
  ];
  const distMM = dist.map(d => (d*mmPerPx).toFixed(2));

  const areas = circles.map(c=>{
    const rMM = c.radius*mmPerPx;
    return (Math.PI*rMM*rMM).toFixed(2);
  });
  const radiiMM = circles.map(c => (c.radius*mmPerPx).toFixed(2));

  const header = 'ラベル,半径(mm),面積(mm²),過去-現在距離(mm),現在-未来距離(mm),過去-未来距離(mm)';
  // この例では [0,1,2] の順で出力
  const row1 = `${circles[0].label},${radiiMM[0]},${areas[0]},${distMM[0]},${distMM[1]},${distMM[2]}`;
  const row2 = `${circles[1].label},${radiiMM[1]},${areas[1]},,,`;
  const row3 = `${circles[2].label},${radiiMM[2]},${areas[2]},,,`;

  const csvContent = [header, row1, row2, row3].join('\n');
  const blob = new Blob([csvContent], {type: 'text/csv;charset=utf-8;'});
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `circle_test_${new Date().toISOString().slice(0,10)}.csv`;
  link.click();
}

function calcDistance(c1, c2) {
  return Math.hypot(c1.x - c2.x, c1.y - c2.y);
}

// 画像保存
async function saveCircleImage() {
  // ラベルを一時的に強制表示
  const originalShow = circles.map(c => c.showText);
  circles.forEach(c => c.showText = true);
  redrawCircleCanvas();

  await new Promise(res => setTimeout(res, 100));
  html2canvas(document.querySelector('.a4-sheet'), {
    scale: 2,
    useCORS: true
  }).then(canvas => {
    const link = document.createElement('a');
    link.download = `circle_test_${new Date().toISOString().slice(0,10)}.jpg`;
    link.href = canvas.toDataURL('image/jpeg', 0.9);
    link.click();

    // 元に戻す
    circles.forEach((c,i) => c.showText = originalShow[i]);
    redrawCircleCanvas();
  });
}

</script>
</body>
</html>
